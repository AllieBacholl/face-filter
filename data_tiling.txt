Data tiling is necessary for the accelerator and the current plan is a tile is conceptually 
C by 3 by 18 (or 33 depending on the stride).
The order is as follows: NOTE THIS IS HOW DATA IS PLACED ON BRAM
row 0, col[0:17] (or col[0:32]), chan 0
row 1, col[0:17] (or col[0:32]), chan 0
row 2, col[0:17] (or col[0:32]), chan 0
row 0, col[0:17] (or col[0:32]), chan 1
row 1, col[0:17] (or col[0:32]), chan 1
row 2, col[0:17] (or col[0:32]), chan 1
...
row 0, col[0:17] (or col[0:32]), chan #LAST_CHAN
row 1, col[0:17] (or col[0:32]), chan #LAST_CHAN
row 2, col[0:17] (or col[0:32]), chan #LAST_CHAN

but the next tile (or one of the future tiles) is gonna look like

row 1, col[0:17] (or col[0:32]), chan 0
row 2, col[0:17] (or col[0:32]), chan 0
row 3, col[0:17] (or col[0:32]), chan 0
row 1, col[0:17] (or col[0:32]), chan 1
row 2, col[0:17] (or col[0:32]), chan 1
row 3, col[0:17] (or col[0:32]), chan 1
...
row 1, col[0:17] (or col[0:32]), chan #LAST_CHAN
row 2, col[0:17] (or col[0:32]), chan #LAST_CHAN
row 3, col[0:17] (or col[0:32]), chan #LAST_CHAN

SDRAM data storage: NEED A SDRAM READER

channel -> row -> col

[Chan 0, Row 0, Col 0-end]  â†’ Sequential
[Chan 0, Row 1, Col 0-end]
[Chan 0, Row 2, Col 0-end]
...
[Chan 1, Row 0, Col 0-end]
[Chan 1, Row 1, Col 0-end]
...
[Last_Chan, Row 0, Col 0-end]


The order of computation:
for a weight tile in weight tiles:
    replace weight tile
    for a input tile in input tiles:
        replace input tile
        conv
        finishes
        writes back
    calculate scaling factor for channels in weight tiles
    Move output from BRAM to DRAM


1. HOW INPUT is stored in BRAM:

8 bytes by 792 and two of them.
reading is alternated

2. HOW WEIGHT is stored in BRAM:

(9 * 16 bytes wide) blocks of all the layers
or 18 * 8 in this case every two lines are for one cycle of FIFOs.

in_chan 0 (0,0) out_chan 0 --- out_chan 15
in_chan 0 (0,1) out_chan 0 --- out_chan 15
in_chan 0 (0,2) out_chan 0 --- out_chan 15
in_chan 0 (1,0) out_chan 0 --- out_chan 15
...
in_chan 0 (2,2) out_chan 0 --- out_chan 15

in_chan 1 (0,0) out_chan 0 --- out_chan 15
in_chan 1 (0,1) out_chan 0 --- out_chan 15
in_chan 1 (0,2) out_chan 0 --- out_chan 15
in_chan 1 (1,0) out_chan 0 --- out_chan 15
...
in_chan 1 (2,2) out_chan 0 --- out_chan 15

in_chan #LAST_IN_CHAN (0,0) out_chan 0 --- out_chan 15
in_chan #LAST_IN_CHAN (0,1) out_chan 0 --- out_chan 15
in_chan #LAST_IN_CHAN (0,2) out_chan 0 --- out_chan 15
in_chan #LAST_IN_CHAN (1,0) out_chan 0 --- out_chan 15
...
in_chan #LAST_IN_CHAN (2,2) out_chan 0 --- out_chan 15

DEPTH of 16 byte wide BRAM is currently 8192
and of course it doubles if 8 byte BRAM is used

3. HOW OUTPUT is stored in BRAM:

8 bytes * 8192




